---
title: "tickfat"
output: html_document
date: "2024-10-08"
---

```{r setup, include=FALSE}

#install packages
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("googlesheets4")) install.packages("googlesheets4")
if (!require("janitor")) install.packages("janitor")
if (!require("lubridate")) install.packages("lubridate")
if (!require("readxl")) install.packages("readxl")
if (!require("MuMIn")) install.packages("MuMIn")
if (!require("MASS")) install.packages("MASS")
if (!require("pscl")) install.packages("pscl")
if (!require("ggokabeito")) install.packages("ggokabeito")
if (!require("remotes")) install.packages("remotes")
if (!require("animation")) install.packages("animation")
if (!require("cowsay")) install.packages("cowsay")
if (!require("survminer")) install.packages("survminer")
if(!require(devtools)) install.packages("devtools")

#manually turn these off after install
#devtools::install_github("kassambara/survminer", build_vignettes = FALSE)
#remotes::install_github("trobinj/trtools")

#set working directory to present directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()

#load libraries
library(tidyverse)
library(googlesheets4)
library(janitor)
library(lubridate)
library(readxl)
library(MuMIn)
library(MASS)
library(pscl)
library(ggokabeito)
library(animation)
library(cowsay)
library(survminer)

#for making reports
knitr::opts_chunk$set(echo = TRUE)
```
```{r import}
df_raw <- suppressWarnings(
  read_sheet(
    "https://docs.google.com/spreadsheets/d/1px-Ldt1EfCNNAWOFSrFH69v8FHLSb1imCDa9wuUgJCc/edit?usp=sharing", 
    sheet = "weigh_data"
    )
) |>
  clean_names()

df_raw <- as_tibble(df_raw)
```
```{r data wrangle}

#extracts 2nd digit into treatment variable
df_wrangled <- df_raw |> mutate(
  treatment = str_match(tick_id, "[A-Z]([0-9]).*")[,2]
)

```
```{r data calculations}

df_calc <- df_wrangled |>
  rowwise() |>
  mutate(
    dess_wt_mean = mean(c_across(starts_with("dess_wt")), na.rm = TRUE), 
    dess_wt_sd = sd(c_across(starts_with("dess_wt")), na.rm = TRUE), .after = dess_wt_4
  ) |>
   mutate(
    xt_wt_mean = mean(c_across(starts_with("xt_wt")), na.rm = TRUE), 
    xt_wt_sd = sd(c_across(starts_with("xt_wt")), na.rm = TRUE), .after = xt_wt_3
  ) |>
  mutate(
    body_fat_raw = dess_wt_mean-xt_wt_mean,
    pct_bf = body_fat_raw/dess_wt_mean, 
    )
  
```
```{r plots}

#survival plot
require("survival")
fit <- survfit(Surv(time, dead) ~ treatment, data = df_calc)
ggsurvplot(fit, data = df_calc)

#converted to barchart from fit object
tibble(time = fit$time, surv = fit$surv, treatment = c(0:5)) |>
  filter(time == 1) |>
  ggplot(
    aes(x = treatment, y = surv)
    ) +
  geom_bar(
    stat = "identity", 
    position = "dodge"
    ) +
  labs(
    title = "Percent survival at 4 wk",
    subtitle = "High to low humidity", 
    x = "humidity treatment", 
    y = "survival"
  )

#scatterplot of body fat proportion
scplot <- df_calc |>
  filter(dead == 0 & lost_legs == 0) |>
  ggplot(
    aes(x=treatment, y = pct_bf, color = sex_m_f)
  ) +
  geom_point(
    position = position_dodge(width = 0.5), 
    size = 1
    ) +
  labs(
    title = "Body Fat Proportion",
    x = "humidity treatment", 
    y = "percent body fat",
  ) +
  theme_classic()
scplot

#barplot of body fat proportion
bplot <- df_calc |>
filter(dead == 0 & lost_legs == 0) |>
  ggplot(
    aes(x=treatment, y = pct_bf)
  ) +
  geom_boxplot(aes(fill = sex_m_f)) +
  labs(
    title = "Body Fat Proportion",
    x = "humidity treatment", 
    y = "percent body fat",
  ) +
  theme_classic()
bplot

```

```{r tickfat stats}
aov.tick <- aov(pct_bf ~ treatment+sex_m_f, data = df_calc)
summary(aov.tick)
```

```{r stats demos}

t <- t.test(pct_bf ~ sex_m_f, data = df)
tstat <- t$statistic

#the t statistic is the difference between means (0.321-0.197) divided by the variance (standard error; 0.00792)

#generates T distribution
x <- seq(-4, 4, length=100)     
y <-  dt(x, df = 198)      

stdt <- tibble(x,y)

stdtplot <- stdt |> ggplot(aes(x = x, y = y)) +
  geom_line() +
  geom_vline(xintercept = 1, color = "darkblue")+
  geom_vline(xintercept = -1, color = "darkblue")+
  geom_vline(xintercept = 2, color = "lightblue")+
  geom_vline(xintercept = -2, color = "lightblue")+
  #includes t statistic from our test
  geom_vline(xintercept = tstat, color = "orange") +
   theme_bw()

stdtplot


#test for normality

#demo
# Create two independent sample datasets
set.seed(123) # for reproducibility
group1 <- rnorm(30, mean = 50, sd = 10)
group2 <- rnorm(35, mean = 55, sd = 12)

# Check normality for each group visually
hist(group1, main = "Histogram of Group 1")
hist(group2, main = "Histogram of Group 2")

qqnorm(group1, main = "Q-Q Plot of Group 1")
qqline(group1)

qqnorm(group2, main = "Q-Q Plot of Group 2")
qqline(group2)

# Perform Shapiro-Wilk test for each group
shapiro.test(group1)
shapiro.test(group2)

males <- df |>
filter(sex_m_f == "M")

females <- df |>
filter(sex_m_f == "F")

hist(males$pct_bf,main = "Histogram of pct_bf_males", plot = TRUE)
hist(females$pct_bf,main = "Histogram of pct_bf_females", plot = TRUE)

qqnorm(males$pct_bf, main = "Normal Q-Q Plot_Males",
       xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
       plot.it = TRUE, datax = FALSE)
qqnorm(females$pct_bf, main = "Normal Q-Q Plot_Females",
       xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
       plot.it = TRUE, datax = FALSE)

shapiro.test(males$pct_bf)
shapiro.test(females$pct_bf)

#nonparametric test
wilcox.test(pct_bf~sex_m_f, data = df)
  
#ANOVA
#generate three populations
p1 <- rnorm(25, 25, 3)
p2 <- rnorm(25, 40, 6)
p3 <- rnorm(25, 15, 6)

df <- tibble(p1, p2, p3) |>
 pivot_longer(everything(), names_to = "pop")
df

df_calc <- df |>
  mutate(
    ss = (value-25)^2
  )

df_calc |> 
  group_by(pop) |>
  summarise(sst = mean(ss))

lm(value ~ pop, data = df)

df_anova <- aov(value ~ pop, data = df)
summary(df_anova)


```
```{r Galton Box}
quincunx = function(
  balls = 250, layers = 15, pch.layers = 2, pch.balls = 19,
  col.balls = sample(colors(), balls, TRUE), cex.balls = 2
) {
  op = par(mar = c(1, 0.1, 0.1, 0.1), mfrow = c(2, 1)); on.exit(par(op))
  if (ani.options('nmax') != (balls + layers - 2))
    warning("It's strongly recommended that ani.options(nmax = balls + layers -2)")
  nmax = max(balls + layers - 2, ani.options('nmax'))
  layerx = layery = NULL
  for (i in 1:layers) {
    layerx = c(layerx, seq(0.5 * (i + 1), layers - 0.5 * (i - 1), 1))
    layery = c(layery, rep(i, layers - i + 1))
  }
  ballx = bally = matrix(nrow = balls, ncol = nmax)
  finalx = numeric(balls)
  for (i in 1:balls) {
    ballx[i, i] = (1 + layers)/2
    if (layers > 2) {
      tmp = rbinom(layers - 2, 1, 0.5) * 2 - 1
      ballx[i, i + 1:(layers - 2)] = cumsum(tmp) * 0.5 + (1 + layers)/2
    }
    bally[i, (i - 1) + 1:(layers - 1)] = (layers - 1):1
    finalx[i] = ballx[i, i + layers - 2]
  }
  rgx = c(1, layers)
  rgy = c(0, max(table(finalx)))
  for (i in 1:ani.options('nmax')) {
    dev.hold()
    plot(1:layers, type = 'n', ann = FALSE, axes = FALSE)
    points(layerx, layery, pch = pch.layers)
    points(ballx[, i], bally[, i], pch = pch.balls, col = col.balls, cex = cex.balls)
    par(bty = 'u')
    if (i < layers - 1) plot.new() else {
      hist(finalx[1:(i - layers + 2)], breaks = 1:layers, xlim = rgx, ylim = rgy,
           main = '', xlab = '', ylab = '', ann = FALSE, axes = FALSE)
    }
    ani.pause()
  }
  invisible(c(table(finalx)))
}
```


