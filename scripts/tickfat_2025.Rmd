---
title: "tickfat"
output: html_document
date: "2024-10-08"
---

```{r setup, include=FALSE}

#install packages
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("googlesheets4")) install.packages("googlesheets4")
if (!require("janitor")) install.packages("janitor")
if (!require("lubridate")) install.packages("lubridate")
if (!require("readxl")) install.packages("readxl")
if (!require("MuMIn")) install.packages("MuMIn")
if (!require("MASS")) install.packages("MASS")
if (!require("pscl")) install.packages("pscl")
if (!require("ggokabeito")) install.packages("ggokabeito")
if (!require("remotes")) install.packages("remotes")
if (!require("animation")) install.packages("animation")
if (!require("cowsay")) install.packages("cowsay")
#remotes::install_github("trobinj/trtools")

#set working directory to present directory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
#load libraries
library(tidyverse)
library(googlesheets4)
library(janitor)
library(lubridate)
library(readxl)
library(MuMIn)
library(MASS)
library(pscl)
library(ggokabeito)
library(animation)
library(cowsay)

knitr::opts_chunk$set(echo = TRUE)
```
```{r import}
df_raw <- suppressWarnings(
  read_sheet(
    "https://docs.google.com/spreadsheets/d/1px-Ldt1EfCNNAWOFSrFH69v8FHLSb1imCDa9wuUgJCc/edit?usp=sharing", 
    sheet = "weigh_data"
    )
)

df_raw <- as_tibble(df_raw)
```
```{r data calculations}
df <- df_raw |>
  mutate(
    body_fat = dess_wt_1-xt_wt_1,
    pct_bf = body_fat/dess_wt_1, 
    )
  
```
```{r plots}

scplot <- df |>
  ggplot(
    aes(x=sex_m_f, y = pct_bf, group = sex_m_f)
  ) +
  geom_point()
  labs(
    title = "body fat proportion",
    x = "treatment", y = "pct_body_fat",
  ) 
scplot

bplot <- df |>
  ggplot(
    aes(x=treatment, y = pct_bf, group = sex_m_f)
  ) +
  geom_boxplot(aes(fill = sex_m_f)) +
  labs(
    title = "body fat proportion",
    x = "treatment", y = "pct_body_fat",
  ) 
bplot

```

```{r stats}

t <- t.test(pct_bf ~ sex_m_f, data = df)
tstat <- t$statistic

#the t statistic is the difference between means (0.321-0.197) divided by the variance (standard error; 0.00792)

#generates T distribution
x <- seq(-4, 4, length=100)     
y <-  dt(x, df = 198)      

stdt <- tibble(x,y)

stdtplot <- stdt |> ggplot(aes(x = x, y = y)) +
  geom_line() +
  geom_vline(xintercept = 1, color = "darkblue")+
  geom_vline(xintercept = -1, color = "darkblue")+
  geom_vline(xintercept = 2, color = "lightblue")+
  geom_vline(xintercept = -2, color = "lightblue")+
  #includes t statistic from our test
  geom_vline(xintercept = tstat, color = "orange") +
   theme_bw()

stdtplot


#test for normality

#demo
# Create two independent sample datasets
set.seed(123) # for reproducibility
group1 <- rnorm(30, mean = 50, sd = 10)
group2 <- rnorm(35, mean = 55, sd = 12)

# Check normality for each group visually
hist(group1, main = "Histogram of Group 1")
hist(group2, main = "Histogram of Group 2")

qqnorm(group1, main = "Q-Q Plot of Group 1")
qqline(group1)

qqnorm(group2, main = "Q-Q Plot of Group 2")
qqline(group2)

# Perform Shapiro-Wilk test for each group
shapiro.test(group1)
shapiro.test(group2)

males <- df |>
filter(sex_m_f == "M")

females <- df |>
filter(sex_m_f == "F")

hist(males$pct_bf,main = "Histogram of pct_bf_males", plot = TRUE)
hist(females$pct_bf,main = "Histogram of pct_bf_females", plot = TRUE)

qqnorm(males$pct_bf, main = "Normal Q-Q Plot_Males",
       xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
       plot.it = TRUE, datax = FALSE)
qqnorm(females$pct_bf, main = "Normal Q-Q Plot_Females",
       xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
       plot.it = TRUE, datax = FALSE)

shapiro.test(males$pct_bf)
shapiro.test(females$pct_bf)

#nonparametric test
wilcox.test(pct_bf~sex_m_f, data = df)
  

```
```{r}
quincunx = function(
  balls = 250, layers = 15, pch.layers = 2, pch.balls = 19,
  col.balls = sample(colors(), balls, TRUE), cex.balls = 2
) {
  op = par(mar = c(1, 0.1, 0.1, 0.1), mfrow = c(2, 1)); on.exit(par(op))
  if (ani.options('nmax') != (balls + layers - 2))
    warning("It's strongly recommended that ani.options(nmax = balls + layers -2)")
  nmax = max(balls + layers - 2, ani.options('nmax'))
  layerx = layery = NULL
  for (i in 1:layers) {
    layerx = c(layerx, seq(0.5 * (i + 1), layers - 0.5 * (i - 1), 1))
    layery = c(layery, rep(i, layers - i + 1))
  }
  ballx = bally = matrix(nrow = balls, ncol = nmax)
  finalx = numeric(balls)
  for (i in 1:balls) {
    ballx[i, i] = (1 + layers)/2
    if (layers > 2) {
      tmp = rbinom(layers - 2, 1, 0.5) * 2 - 1
      ballx[i, i + 1:(layers - 2)] = cumsum(tmp) * 0.5 + (1 + layers)/2
    }
    bally[i, (i - 1) + 1:(layers - 1)] = (layers - 1):1
    finalx[i] = ballx[i, i + layers - 2]
  }
  rgx = c(1, layers)
  rgy = c(0, max(table(finalx)))
  for (i in 1:ani.options('nmax')) {
    dev.hold()
    plot(1:layers, type = 'n', ann = FALSE, axes = FALSE)
    points(layerx, layery, pch = pch.layers)
    points(ballx[, i], bally[, i], pch = pch.balls, col = col.balls, cex = cex.balls)
    par(bty = 'u')
    if (i < layers - 1) plot.new() else {
      hist(finalx[1:(i - layers + 2)], breaks = 1:layers, xlim = rgx, ylim = rgy,
           main = '', xlab = '', ylab = '', ann = FALSE, axes = FALSE)
    }
    ani.pause()
  }
  invisible(c(table(finalx)))
}
```


